{"Q_ID": "1115210005", "S_NAME": "Arrays", "Q_NAME": "Boolean Expressions-CARA004", "Q_DESC": "Roy is intrigued by the fact that the evaluated value of boolean expressions can easily vary depending upon the order of evaluation !\n\nFor instance, consider the example:\n\nExpression: 1 xor 1 and 0\n\nWe can have following two interpretations:\n\n1.  ((1 xor 1) and 0) => (0 and 0) => 0\n\n2.  (1 xor (1 and 0)) => (1 xor 0) => 1\n\nNow, he is further interested into finding the number of possible different parenthesizations such that the result of computation is res.\n\nInput:\n\nThe first line of input file contains two space-separated strings. The first string denotes the literals of our boolean expression S, the second string denotes the operators. The next line denotes an integer q, i.e. the number of queries to follow. Each of the next q lines contain two space separated integers l and r and a string res, which is either true or false.\n\nOutput:\n\nFor each query. output in a new line, the number of ways in which the boolean expression of substring [l,r] can be parenthesized so that it evaluates to res. As the output can be very large, please print the answer modulo 1000000009.\n\nConstraints:\n\n1 <= |S| <= 300\n1 <= q <= 90000\n1 <= l <= r <= |S|\n\n", "TESTCASE_1": "110 ax\n3\n1 1 true\n1 2 false\n2 3 false\n###---###SEPERATOR---###---\n1\n0\n0", "TESTCASE_2": "0\n###---###SEPERATOR---###---\n0", "TESTCASE_3": "120 qo\n4\n0 0 true\n0 0 false\n1 1 true\n1 1 false\n###---###SEPERATOR---###---\n0\n0\n1\n0", "TESTCASE_4": "0\n###---###SEPERATOR---###---\n0", "TESTCASE_5": "0 ###---###SEPERATOR---###--- 0"}