{"Q_ID": "1416210002", "S_NAME": "Stack Implementation", "Q_NAME": "Stack 32", "Q_DESC": "Sergey recently studied lock-free data structures. He particularly liked the data structure called Lock-Free Stack.\n\nSo, lock-free stack is basically an ordinary stack, which can be used by multiple threads of the same program. There are N threads, which do push and pop the numbers to this stack simultaneously.\n\nIn order to check his knowledge, Sergey implemented this data structure. But he was still unsure, whether his code works correct or not. So he made the test case of the following kind:\n\nFor every thread (say, the ith), there is a list of Ai numbers, which will be pushed to the stack by this thread in this order (so, first, the first number from this list will be added, then the second one, and so on).\nSo Sergey runs the program, the numbers get pushed to the stack from all the threads simultaneously. When all the threads are done with it, he wanted to pop all the numbers from the stack and to check the correctness of the output.\n\nBut it appeared to be not so easy problem, because in general, there could be a few different correct sequences he could obtain, because the order in which the processes add the numbers is not strictly defined. Moreover, the processes can interrupt in between.\n\nFor example, even if he had only two threads and for each of them, there was a list of 1 unique number, then there can be two valid orders: either the first thread added its' number first, or it was the second one.\n\nThe another example could be the following: if there are also two thread, the first one having the list (1, 2) and the second one having the list (3, 4), then after doing all pops even the sequence (4, 2, 3, 1) is correct, because in this case:\n\nFirst, the first thread added the first number 1 from its' list;\nThen, the second thread added the first number 3 from its' list;\nThen, the first thread added the second number 2 from its' list;\nThen, the second thread added the second number 4 from its' list;\nSo since it is a LIFO (last in, first out) stack, after the pops we get the sequence (4, 2, 3, 1).\nYou are given the number of the threads and the list of integers to be added in order for each of the threads. You are also given a sequence. Determine, whether this sequence could be obtained after the process described above.\n\nInput\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n\nThe first line of each test case contains a single integer N denoting the number of threads.\n\nEach of the following N lines contains the description of the numbers to be pushed in the following way: the first number in the list is Ai; the following numbers are the numbers Bi, 1, Bi, 2, ..., Bi, Ai denoting the numbers that will be added to the stack (in this order) by the ith thread.\n\nThe last line on the test case contains A1+A2+...+AN integer numbers, denoting the sequence Sergey got after he popped all the numbers from the stack.\n\nOutput\nFor each test case, output a single line containing Yes, if Sergey could have got this sequence of numbers and No otherwise.\n\nConstraints\n1  T  15\n1  Ai\n1  Bi, j  1000\nLet's denote P = (A1 + 1)  (A2 + 1)  ...  (AN + 1)\n1  sum of P  106\nSubtaks\nSubtask #1 (33 points): 1  sum of P  1000\nSubtask #2 (11 points): N = 1\nSubtask #3 (56 points): no additional constraints", "TESTCASE_1": "2\n2\n2 1 2\n2 3 4\n4 3 2 1\n2\n2 1 2\n2 3 4\n4 1 2 3\n###---###SEPERATOR---###---\nYes\nNo", "TESTCASE_2": "2\n2\n1 1 7\n4 7 6\n7 6 4 1\n2\n9 1 9\n3 4 9\n9 1  3 4\n###---###SEPERATOR---###---\nNo\nNo", "TESTCASE_3": "0\n###---###SEPERATOR---###---\n0", "TESTCASE_4": "0\n###---###SEPERATOR---###---\n0", "TESTCASE_5": "0\n###---###SEPERATOR---###---\n0"}