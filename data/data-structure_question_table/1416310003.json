{"Q_ID": "1416310003", "S_NAME": "Stack Implementation", "Q_NAME": "Stack 47", "Q_DESC": "Depth First Traversal (or Search) for a graph is similar to Depth First Traversal of a tree. The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again. To avoid processing a node more than once, we use a boolean visited array. \nFor example, in the following graph, we start traversal from vertex 2. When we come to vertex 0, we look for all adjacent vertices of it. 2 is also an adjacent vertex of 0. If we dont mark visited vertices, then 2 will be processed again and it will become a non-terminating process. A Depth First Traversal of the following graph is 2, 0, 1, 3.\n\nINPUT:\nEnter the number of nodes in a graph\nEnter the value of node of graph\nEnter the value in adjancency matrix in form of 'Y' or 'N'\nIf there is an edge between the two vertices then enter 'Y' or 'N'\nOUTPUT:\nDFS  of the graph sequence is obtained", "TESTCASE_1": "5\na b c d  e\nnyny\nynyn\nnyny\nynyn\nnnyy\n###---###SEPERATOR---###---\na b c d e \na \nn y n y \n\n\nb \ny n y n \n\n\nc \nn y n y \n\n\nd \ny n y n \n\n\ne \nn n y y \n\nDFS of Graph : a e d b c", "TESTCASE_2": "6\na b c d  e f\nnynyy\nynnyy\nyynyn\nynyyn\nnnyny\nnyynn\n###---###SEPERATOR---###---\na b c d e f \na \nn y n y y \n\n\nb \ny n n y y \n\n\nc \ny y n y n \n\n\nd \ny n y y n \n\n\ne \nn n y n y \n\n\nf \nn y y n n \n\nDFS of Graph : a f d e b c", "TESTCASE_3": "0\n###---###SEPERATOR---###---\n0", "TESTCASE_4": "0\n###---###SEPERATOR---###---\n0", "TESTCASE_5": "0\n###---###SEPERATOR---###---\n0"}