{"Q_ID": "1417110014", "S_NAME": "Queue  Implementation", "Q_NAME": "Count the number of islands", "Q_DESC": "Given a binary matrix where 0 represents water and 1 represents land, count the number of islands in it. A island is formed by connected ones.he idea is to start BFS from each unprocessed node and increment the island count. Each BFS traversal will mark all cells which make one island as processed. So the problem reduces to finding number of BFS calls.\n\nIn each BFS traversal, we start by creating an empty queue. Then we enqueue starting cell and mark it as processed. Then we pop front node from the queue and process all 8 adjacent cells of current cell and enqueue each valid cell which is land. We repeat this process till queue is not empty.\n\nWe can find all the possible locations we can move to from the given location by using the array that stores the relative position of movement from any location. For example, if the current location is\n(x, y), we can move to (x + row[k], y + col[k]) for 0 = k = 7 using below array.\n\nint row[ ] = { -1, -1, -1, 0, 0, 1, 1, 1 };\nint col[ ] = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\nSo, from position (x, y), we can move to:\n(x - 1, y-1)\n(x-1, y)\n(x-1, y + 1)\n(x, y-1)\n(x, y + 1)\n(x + 1, y -1)\n(x + 1, y)\n(x + 1, y + 1)\n\nINPUT:\nThe input is 2-Dimensional matrix of 10 columns and 10 rows.\n\nOUTPUT:\nThe number of islands should be printed as output", "TESTCASE_1": "1 0 1 0 0 0 1 1 1 1 \n0 0 1 0 1 0 1 0 0 0 \n1 1 1 1 0 0 1 0 0 0 \n1 0 0 1 0 1 0 0 0 0 \n1 1 1 1 0 0 0 1 1 1 \n0 1 0 1 0 0 1 1 1 1 \n0 0 0 0 0 1 1 1 0 0\n0 0 0 1 0 0 1 1 1 0 \n1 0 1 0 1 0 0 1 0 0 \n1 1 1 1 0 0 0 1 1 1\n###---###SEPERATOR---###---\n5", "TESTCASE_2": "1 0 1 0 0 0 1 1 0 1 \n0 0 1 0 1 0 1 0 0 1\n1 1 1 1 0 0 1 0 0 0 \n1 0 0 1 0 1 0 0 0 0 \n0 0 1 1 0 0 0 1 1 1 \n0 0 0 1 0 0 1 1 1 1 \n0 0 0 0 0 1 1 1 0 0\n0 0 0 1 0 0 1 1 1 0 \n0 0 1 0 1 0 0 1 0 0 \n1 1 1 1 0 0 0 1 1 1\n###---###SEPERATOR---###---\n6", "TESTCASE_3": "1 0 1 0 0 0 1 1 1 1 \n1 0 1 0 1 0 1 0 0 1\n1 1 1 1 0 0 1 0 0 0 \n1 0 0 1 0 1 0 0 0 0 \n0 0 1 1 0 0 0 1 1 1 \n0 0 0 1 0 0 1 1 1 1 \n0 0 0 0 0 1 1 1 0 0\n0 0 0 1 0 0 1 1 1 0 \n0 0 1 1 1 0 0 1 0 0 \n1 1 1 1 0 0 0 1 1 1\n###---###SEPERATOR---###---\n4", "TESTCASE_4": "0\n###---###SEPERATOR---###---\n0", "TESTCASE_5": "0\n###---###SEPERATOR---###---\n0"}