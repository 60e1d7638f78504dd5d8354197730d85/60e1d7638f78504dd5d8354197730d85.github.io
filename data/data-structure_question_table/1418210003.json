{"Q_ID": "1418210003", "S_NAME": "Tree", "Q_NAME": "Mirrors and Trees", "Q_DESC": "Given a binary tree in a two dimensional plane which has both side covered by mirrors. As this is a 2D dimensional image, we define our print function to print only those nodes whose reflection is showing on one of the mirrors, first we print the value of the nodes with reflections appearing on the right mirror and then print the values of the ones appearing on the left and we don't need to print the same node again which has already been printed on right mirror, so each node is going to printed only once even in a case where the node has a reflection on both mirrors.\n\nSuppose in the array representation of binary trees, we fill the positions where the left or right child of a node does not exist with 0s.\nSo the tree \n     3\n\n    / \n\n   2\n\n  /\n\n 1  \nwill look in array representation as 3 2 0 1 0 0 0 0 0 0 0 0 0 0 0 i.e.\n         3\n       /   \\\n      2     0\n     /     / \\\n    1   0  0   0\n   /  /  /  / \\\n  0  0 0 0 0 0 0  0\nand the tree \n    \n\n        1 \n\n       /   \n      2   3\n\nwill look in the array representation as 1 2 3 0 0 0 0 i.e.\n         1\n\n       /    \n      2    3\n\n     /    /   \n    0   0  0  0 \n\nhere for every ith node, it's left child is at (2 * i) th and right child at (2 * i + 1)th position.\nInput:\nFirst line contains number of test cases T. First line of each test case contains a single integer N,size of array and second line contains the tree in array representation form as mentioned above.\n\nOutput:\nFor each test case, first print the value of the nodes with reflections appearing on the right mirror and then print values of the ones appearing on the left and don't need to print the same node again which has already been printed on right mirror, so each node is going to printed only once even in a case where the node has a reflection on both mirrors.\n\nConstraints:\n1<=T<=20 \n3<=N<=2^18\n0<=**Ai<=1000000\n\nNote: \nThe value of N will always be greater than equal to 3 and will be in the form (2^k-1) where k>=2.\nLast level of the tree is filled with all 0s.\nAssume array indices start from 1.", "TESTCASE_1": "2\n7\n1 2 3 0 0 0 0\n7\n1 3 0 0 0 0 0\n###---###SEPERATOR---###---\n1\n3\n2\n\n1\n3\n", "TESTCASE_2": "0\n###---###SEPERATOR---###---\n0", "TESTCASE_3": "0\n###---###SEPERATOR---###---\n0", "TESTCASE_4": "0\n###---###SEPERATOR---###---\n0", "TESTCASE_5": "0\n###---###SEPERATOR---###---\n0"}