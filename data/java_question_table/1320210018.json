{"Q_ID": "1320210018", "S_NAME": "Generics and Collections", "Q_NAME": "Smallest and Largest SubString", "Q_DESC": "We define the following terms:\n\n-> Lexicographical Order, also known as alphabetic or dictionary order, orders characters as follows: \nA < B < ... < Y < Z < a < b < ..... < y < z\nFor example, ball < cat, dog < dorm, Happy < happy, Zoo < ball.\n\n-> A substring of a string is a contiguous block of characters in the string. For example, the substrings of abc are a, b, c, ab, bc, and abc.\nGiven a string s ,k , and an integer, , complete the function so that it finds the lexicographically smallest and largest substrings of length k.\n\nInput Format\n\nThe first line contains a string denoting s. \nThe second line contains an integer denoting k.\n\nConstraints\n->  1 <= s <= 1000\n->  s consists of English alphabetic letters only (i.e., [a-zA-Z]).\n\nOutput Format\n\nReturn the respective lexicographically smallest and largest substrings as a single newline-separated string.\n\nSample Input 0\n\nwelcometojava\n3\n\nSample Output 0\n\nava\nwel\n\nExplanation 0\n\nString s = \"welcometojava\" has the following lexicographically-ordered substrings of length k=3:\n[\"ava\",\"com\",\"elc\",\"eto\",\"jav\",\"met\",\"oja\",\"ome\",\"toj\",\"wel\"]\n\nWe then return the first (lexicographically smallest) substring and the last (lexicographically largest) substring as two newline-separated values (i.e., ava\\nwel).\n\nThe stub code in the editor then prints ava as our first line of output and wel as our second line of output.", "TESTCASE_1": "welcometojava\n3\n###---###SEPERATOR---###---\nava\nwel", "TESTCASE_2": "hitmansuperman\n4\n###---###SEPERATOR---###---\nansu\nuper", "TESTCASE_3": "ramkrishna\n5\n###---###SEPERATOR---###---\namkri\nrishn", "TESTCASE_4": "hackerrank\n6\n###---###SEPERATOR---###---\nackerr\nkerran", "TESTCASE_5": "0\n###---###SEPERATOR---###---\n0"}